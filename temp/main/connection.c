/* * Copyright (C) 2015 The CloudKit Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *///// 2017/5/31.///* 包含相关的头文件 */#include "connection.h"// void *listening(configuration_t *cfg) {}/** * Get the transport, to which this connection belongs to. * * @param argc * @param argv * @return the transport, to which this connection belongs to. * */int get_transport(int argc, char *argv[]) {    // 定义相关的变量，服务器端套接字、客户端套接字    int server_sockfd, is_connected[MAX_CONN], sockfd;    int option = 1;    /* 服务器网络地址结构体 */    struct sockaddr_in local_addr;    // 数据初始化清零    // memset(&local_addr, 0, sizeof(local_addr));    // 清空local_addr所在的内存    bzero(&local_addr, sizeof(local_addr));    // 设置为IP通信    local_addr.sin_family = AF_INET;    // 服务器IP地址 允许连接到所有本地地址上 */    local_addr.sin_addr.s_addr = htonl(INADDR_ANY);    // 服务器端口号    local_addr.sin_port = htons(SERV_PORT);    // 建立一个 socket，创建服务器端套接字 IPv4 协议，面向连接通信，TCP 协议    if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {        perror("socket");        // exit(1);    } else {        /* socket建立成功，输出提示 */        printf("socket created. socked id: %d\n", server_sockfd);    }    // SO_REUSEADDR 支持多个进程或者线程不同IP绑定到同一端口、SO_REUSEPORT 支持多个进程或者线程绑定到同一端口    if (setsockopt(server_sockfd, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option)) == -1) {        perror("setsockopt");        // die("setsockopt");        // exit(1);    }    // 绑定端口，将套接字绑定到服务器的网络地址上    if (bind(server_sockfd, (struct sockaddr *) &local_addr, sizeof(local_addr)) < 0) {        perror("bind");        // exit(1);    } else {        printf("connected. local address: %s, local port: %d\n", inet_ntoa(local_addr.sin_addr), ntohs(local_addr.sin_port));    }    // 开始监听，监听连接请求，监听队列长度为 5    if (listen(server_sockfd, 5) < 0) {        perror("listen");        // exit(1);    } else {        printf("listening......\n");    }    for (sockfd = 0; sockfd < MAX_CONN; sockfd++) {        // 设置所有的标记为 0        is_connected[sockfd] = 0;    }}