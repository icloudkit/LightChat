/* * Copyright (C) 2015 The CloudKit Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *///// 2017/5/31.///* 包含相关的头文件 */#include "connection.h"// void *listening(configuration_t *cfg) {}/** * Get the transport, to which this connection belongs to. * * @param argc * @param argv * @return the transport, to which this connection belongs to. * */int get_transport(int argc, char *argv[]) {    /* 定义相关的变量，服务器端套接字、客户端套接字*/    int server_sockfd, client_sockfd, is_connected[MAX_CONN], sockfd;    int option = 1;    /* 服务器网络地址结构体、客户端网络地址结构体 */    struct sockaddr_in my_addr, client_addr;    int sin_size = sizeof(struct sockaddr_in);    /* 数据传送的缓冲区 */    char my_buffer[BUFSIZ];    char message[] = "Welcome to my server. Connected.\n";    /* select()机制中，fd_set的数据结构，当调用select()时，由内核根据IO状态修改fe_set的内容，由此来通知执行了select()的进程哪一socket或文件可读 */    struct fd_set fds;    /* select等待3秒，3秒轮询，要非阻塞就置0 */    struct timeval timeout = {3, 0};    /* 数据初始化清零 */    memset(&my_addr, 0, sizeof(my_addr));    memset(&client_addr, 0, sizeof(client_addr));    /* 清空my_addr所在的内存 */    bzero(&my_addr, sizeof(my_addr));    /* 设置为IP通信 */    my_addr.sin_family = AF_INET;    /* 服务器IP地址 允许连接到所有本地地址上 */    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);    /* 服务器端口号 */    my_addr.sin_port = htons(SERV_PORT);    /* 建立一个socket，创建服务器端套接字 IPv4协议，面向连接通信，TCP协议 */    if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {        perror("socket");        // exit(1);        return 1;    } else {        /* socket建立成功，输出提示 */        printf("socket created .\n");        printf("socked id: %d \n", server_sockfd);    }    // SO_REUSEADDR 支持多个进程或者线程不同IP绑定到同一端口、SO_REUSEPORT 支持多个进程或者线程绑定到同一端口    if (setsockopt(server_sockfd, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option)) == -1) {        perror("setsockopt");        // die("setsockopt");        // exit(1);        return 1;    }    /* 绑定端口，将套接字绑定到服务器的网络地址上 */    if (bind(server_sockfd, (struct sockaddr *) &my_addr, sizeof(my_addr)) < 0) {        perror("bind");        // exit(1);        return 1;    } else {        printf("connected.\n");        printf("local port:%d\n", SERV_PORT);    }    /* 开始监听，监听连接请求，监听队列长度为 5 */    if (listen(server_sockfd, 5) < 0) {        perror("listen");        // exit(1);        return 1;    } else {        printf("listening......\n");    }    for (sockfd = 0; sockfd < MAX_CONN; sockfd++) {        /* 设置所有的标记为0 */        is_connected[sockfd] = 0;    }    /* 进入一个循环，处理所有的连接 */    while (1) {        /* 清空一个标志，将set清零使集合中不含任何fd */        FD_ZERO(&fds);        /* 设置标志，将fd加入set集合 */        FD_SET(server_sockfd, &fds);        for (sockfd = 0; sockfd < MAX_CONN; sockfd++) {            /* 判断有没有连接 */            if (is_connected[sockfd]) {                /* 设置标志 */                FD_SET(sockfd, &fds);            }        }        /* 如果达到了最大连接数则进入下次循环 */        if (!select(MAX_CONN, &fds, &fds, NULL, &timeout)) {            continue;        }        /* 进入一个循环 */        for (sockfd = 0; sockfd < MAX_CONN; sockfd++) {            /* 判断标志，测试sockfd是否在set集合中 FD_CLR(sockfd, &set); 将sockfd从set集合中清除 */            if (FD_ISSET(sockfd, &fds)) {                /* 如果新建的socket与sockfd相同 */                if (server_sockfd == sockfd) {                    /* 等待客户端连接请求到达，接受一个连接，新建一个socket */                    if ((client_sockfd = accept(server_sockfd, (struct sockaddr *) &client_addr, &sin_size)) < 0) {                        perror("accept");                        return 1;                    }                    /* 给客户端发送一段信息 */                    write(client_sockfd, message, sizeof(message));                    /* 设置标志 */                    is_connected[client_sockfd] = 1;                    /* 输出客户端IP */                    printf("accept client %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));                } else {                    /* 清空字符串 sizeof(my_buffer) */                    bzero(my_buffer, BUFSIZ);                    /* 读取客户端的数据 recvfrom() */                    if (read(sockfd, my_buffer, BUFSIZ) <= 0) {                        /* 输出连接关闭 */                        printf("connect closed.\n");                        /* 设置标志 */                        is_connected[sockfd] = 0;                        /* 关闭一个socket */                        close(sockfd);                    } else {                        /* 发送接收到的信息 strlen(my_buffer) */                        write(sockfd, my_buffer, BUFSIZ);                        /* 输出接收到的信息 */                        printf("message:%s\n", my_buffer);                    }                }            }        }        // assert(0 != 0);        // return 0;    }}